# -*- coding: utf-8 -*-

"""
/***************************************************************************
 FalhaDePlantio
                                 A QGIS plugin
 --REMASTERIZADO--Pluing utilizado para mapeamento de falha de plantio na cultura de cana-de-açúcar
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-09-25
        copyright            : (C) 2022 by 
        email                : email
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'cainc0de'
__date__ = '2022-09-25'
__copyright__ = '(C) 2022 by '

# This will get replaced with a git SHA1 when you do a git archive

from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProject)
import processing
from qgis.PyQt.QtGui import QIcon

class FalhaDePlantioAlgorithm(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterRasterLayer('gligreenleafindex', '1. Raster para Análise (Drone)', defaultValue=None))
        self.addParameter(QgsProcessingParameterRasterLayer('input_raster_linhas', '2. [OPCIONAL] Imagem para GERAR Linhas Automáticas', defaultValue=None, optional=True))
        self.addParameter(QgsProcessingParameterVectorLayer('linhaplantio', '3. [OPCIONAL] Camada de Linhas Manual', types=[QgsProcessing.TypeVectorLine], defaultValue=None, optional=True))
        self.addParameter(QgsProcessingParameterVectorLayer('quadra', '4. Contorno do Talhão', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        
        self.addParameter(QgsProcessingParameterFeatureSink('LinhasGeradasOutput', 'Linhas de Plantio Extraídas (Visualização)', type=QgsProcessing.TypeVectorLine, createByDefault=True, optional=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('FalhaDePlantio', 'Resultado Final das Falhas', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))

    def processAlgorithm(self, parameters, context, model_feedback):
        feedback = QgsProcessingMultiStepFeedback(15, model_feedback)
        results = {}
        outputs = {}
        
        context.setTransformContext(QgsProject.instance().transformContext())
        project_crs = QgsProject.instance().crs().authid()

        # --- FASE 1: DEFINIÇÃO DAS LINHAS DE PLANTIO ---
        if parameters['input_raster_linhas']:
            feedback.pushInfo('Iniciando extração automática de linhas...')
            
            # A. Binarização (CORREÇÃO: RTYPE 1 para compatibilidade com GRASS)
            alg_params = {
                'INPUT_A': parameters['input_raster_linhas'], 'BAND_A': 2,
                'INPUT_B': parameters['input_raster_linhas'], 'BAND_B': 1,
                'INPUT_C': parameters['input_raster_linhas'], 'BAND_C': 3,
                'FORMULA': '((2.0*A-B-C)/(2.0*A+B+C+0.0001)) > 0', 
                'RTYPE': 1, # Tipo Inteiro (CELL)
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['BinarioAuto'] = processing.run('gdal:rastercalculator', alg_params, context=context, feedback=feedback)

            # B. Esqueletização (r.thin)
            alg_params = {
                'input': outputs['BinarioAuto']['OUTPUT'], 'iterations': 200,
                'output': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['Esqueleto'] = processing.run('grass7:r.thin', alg_params, context=context, feedback=feedback)

            # C. Vetorização (r.to.vect)
            alg_params = {
                'input': outputs['Esqueleto']['output'], 'type': 0,
                'output': parameters['LinhasGeradasOutput']
            }
            outputs['LinhasProcessadas'] = processing.run('grass7:r.to.vect', alg_params, context=context, feedback=feedback)
            
            v_linhas_base = outputs['LinhasProcessadas']['output']
            results['LinhasGeradasOutput'] = v_linhas_base
        else:
            v_linhas_base = parameters['linhaplantio']

        # --- FASE 2: ANÁLISE DE FALHAS ---
        feedback.setCurrentStep(5)
        
        # 1. Recortar Raster
        outputs['RasterRecortado'] = processing.run('gdal:cliprasterbymasklayer', {
            'INPUT': parameters['gligreenleafindex'], 'MASK': parameters['quadra'],
            'SOURCE_CRS': project_crs, 'TARGET_CRS': project_crs, 'NODATA': 0,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }, context=context, feedback=feedback)

        # 2. Máscara de Vegetação (RTYPE 1 para consistência)
        outputs['VegetacaoMascara'] = processing.run('gdal:rastercalculator', {
            'INPUT_A': outputs['RasterRecortado']['OUTPUT'], 'BAND_A': 2,
            'INPUT_B': outputs['RasterRecortado']['OUTPUT'], 'BAND_B': 1,
            'INPUT_C': outputs['RasterRecortado']['OUTPUT'], 'BAND_C': 3,
            'FORMULA': '((2.0*A-B-C)/(2.0*A+B+C+0.0001)) > 0',
            'RTYPE': 1, 'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }, context=context, feedback=feedback)

        # 3. Poligonizar
        outputs['VegetacaoVetor'] = processing.run('gdal:polygonize', {
            'INPUT': outputs['VegetacaoMascara']['OUTPUT'], 'FIELD': 'DN', 
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }, context=context, feedback=feedback)

        # 4. Extrair Cana (DN=1)
        outputs['CanaPoligonos'] = processing.run('native:extractbyattribute', {
            'FIELD': 'DN', 'INPUT': outputs['VegetacaoVetor']['OUTPUT'], 'OPERATOR': 0, 'VALUE': '1', 
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }, context=context, feedback=feedback)

        # 5. Diferença (Linhas - Cana)
        outputs['FalhasLinhas'] = processing.run('native:difference', {
            'INPUT': v_linhas_base, 'OVERLAY': outputs['CanaPoligonos']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }, context=context, feedback=feedback)

        # 6. Multipartes para Simples
        outputs['SingleParts'] = processing.run('native:multiparttosingleparts', {
            'INPUT': outputs['FalhasLinhas']['OUTPUT'], 'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }, context=context, feedback=feedback)

        # 7. Calcular Comprimento
        processing.run('native:fieldcalculator', {
            'FIELD_NAME': 'comp_m', 'FIELD_TYPE': 0, 'FORMULA': '$length',
            'INPUT': outputs['SingleParts']['OUTPUT'], 'OUTPUT': parameters['FalhaDePlantio']
        }, context=context, feedback=feedback)

        results['FalhaDePlantio'] = parameters['FalhaDePlantio']
        return results

    def name(self): return 'falha_hibrida_cana'
    def displayName(self): return 'Falha de Plantio (Cana - Auto/Manual)'
    def group(self): return 'Análise'
    def groupId(self): return 'Análise'
    def createInstance(self): return FalhaDePlantioAlgorithm()